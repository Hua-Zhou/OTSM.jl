var documenterSearchIndex = {"docs":
[{"location":"#OTSM.jl-1","page":"OTSM.jl","title":"OTSM.jl","text":"","category":"section"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"OTSM.jl implements algorithms for solving the orthogonal trace sum maximization (OTSM) problem $     \\operatorname{maximize} \\sum{i,j=1}^m \\operatorname{tr} (Oi^T S{ij} Oj) $ subject to orthogonality constraint O_i^T O_i = I_r. Here S_ij in mathbbR^d_i times d_j, 1 le i j le m, are data matrices. Many problems such as canonical correlation analysis (CCA) with m ge 2 data sets, Procrustes analysis with m ge 2 images, and orthogonal least squares are special cases of OSTM. ","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"Details on OTSM are described in paper: ","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"Joong-Ho Won, Hua Zhou, and Kenneth Lange. (2018) Orthogonal trace-sum maximization: applications, local algorithms, and global optimality, arXiv. ","category":"page"},{"location":"#Installation-1","page":"OTSM.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"This package requires Julia v1.0 or later, which can be obtained from https://julialang.org/downloads/ or by building Julia from the sources in the https://github.com/JuliaLang/julia repository.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"The package has not yet been registered and must be installed using the repository location. Start julia and use the ] key to switch to the package manager REPL","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"(@v1.4) pkg> add https://github.com/Hua-Zhou/OTSM.jl","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"Use the backspace key to return to the Julia REPL.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"versioninfo()","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"Julia Version 1.4.1\nCommit 381693d3df* (2020-04-14 17:20 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i7-6920HQ CPU @ 2.90GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = 4","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"# for use in this tutorial\nusing OTSM","category":"page"},{"location":"#Example-data-1","page":"OTSM.jl","title":"Example data","text":"","category":"section"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"The package contains one port wine example data set from the Hanafi and Kiers (200) paper. It can be retrieved by the portwine_data() function.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"A, S, = portwine_data();","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"Data matrices A1, A2, A3, A4 record the ratings (centered at 0) of m=4 accessors on 8 port wines in d_1=4, d_2=3, d_3=4, and d_4=3 aspects respectively. ","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"for i in 1:4\n    display(A[i])\nend","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"8×4 Array{Float64,2}:\n  1.25  -5.0  -1.375   3.875\n -0.75   1.0  -0.375  -1.125\n  1.25  -3.0  -1.375   0.875\n -0.75   2.0   0.625  -0.125\n -0.75   2.0  -0.375  -0.125\n  0.25   3.0  -0.375  -3.125\n -0.75  -1.0   3.625  -1.125\n  0.25   1.0  -0.375   0.875\n\n\n\n8×3 Array{Float64,2}:\n  2.0  -4.375   0.625\n  1.0   1.625   0.625\n  1.0  -1.375   2.625\n -1.0   1.625  -1.375\n  0.0   0.625   0.625\n -1.0   0.625  -0.375\n -2.0  -0.375  -2.375\n  0.0   1.625  -0.375\n\n\n\n8×4 Array{Float64,2}:\n  3.125   3.0  -2.5   0.75\n -1.875  -1.0   1.5   0.75\n  2.125   2.0  -0.5   1.75\n -1.875  -1.0   1.5  -1.25\n  1.125   0.0   0.5   0.75\n -0.875  -1.0   0.5  -0.25\n -1.875  -1.0  -0.5  -2.25\n  0.125  -1.0  -0.5  -0.25\n\n\n\n8×3 Array{Float64,2}:\n  1.0   0.125   0.375\n  0.0  -0.875  -1.625\n  2.0  -0.875  -1.625\n -1.0   0.125  -0.625\n  0.0   0.125  -0.625\n  0.0   1.125   1.375\n -2.0  -1.875   1.375\n  0.0   2.125   1.375","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"The MAXDIFF approach for CCA seeks the rotations of A_i that achieve the maximal agreement $ \\operatorname{maximize} \\sum{i < j} \\operatorname{tr} (Oi^T Ai^T Aj Oj), $ subject to constraint Oi^T Oi = Ir This corresponds to an OTSM problem with S_ij = A_i^T A_j and S_ii = 0.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"for i in 1:4, j in 1:i\n    display(S[i, j])\nend","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\n\n\n3×4 Array{Float64,2}:\n  5.0   -15.0  -12.0     13.0\n -9.25   36.0    5.875  -20.375\n  5.75  -11.0  -14.125    7.625\n\n\n\n3×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n4×4 Array{Float64,2}:\n  9.75  -26.0  -14.625   21.125\n  8.0   -27.0  -10.0     18.0\n -6.0    21.0    2.5    -13.5\n  4.5    -8.0  -12.75     6.75\n\n\n\n4×3 Array{Float64,2}:\n 13.0  -21.625  14.375\n 11.0  -21.0    11.0\n -5.0   16.5    -2.5\n 10.0   -5.75   13.25\n\n\n\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\n\n\n3×4 Array{Float64,2}:\n 6.0   -11.0  -12.0     8.0\n 1.75    9.0   -6.625   1.125\n 0.25    3.0    6.125  -2.625\n\n\n\n3×3 Array{Float64,2}:\n  9.0  -8.0    12.0\n  1.0   4.375   0.375\n -6.0  -0.875  -8.875\n\n\n\n3×4 Array{Float64,2}:\n 13.0    10.0  -4.0  10.0\n  2.875  -2.0  -0.5   1.25\n -2.375  -4.0  -4.5  -7.25\n\n\n\n3×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"#Proximal-block-ascent-algorithm-1","page":"OTSM.jl","title":"Proximal block ascent algorithm","text":"","category":"section"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"The otsm_bpa() function implements an efficient local search algorithm for solving OTSM.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"Ô_pba, ts_pba, obj, history = otsm_pba(S, 2; verbose = true);","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"iter = 1, obj = 110.25\niter = 2, obj = 533.6042318034453\niter = 3, obj = 542.2027792984238\niter = 4, obj = 542.3265730402211\niter = 5, obj = 542.3275463498419\niter = 6, obj = 542.3275506295132\niter = 7, obj = 542.327550638136","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"For documentation of the otsm_bpa() function, type ?otsm_bpa in Julia REPL.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"@docs\notsm_bpa","category":"page"},{"location":"#Check-global-optimality-of-a-local-solution-1","page":"OTSM.jl","title":"Check global optimality of a local solution","text":"","category":"section"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"The test_optimality() function attempts to certify whether a local solution O::Vector{Matrix} is a global solution. By a local solution, we mean a point that satifies the first order optimality condition: $ \\Lambdai = \\sum{j \\ne i} Oi^T S{ij} O_j $ is symmetric for i=1ldotsm. The first output indicates the solution is global optimal (1), or uncertain (0), or suboptimal (-1).","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"# proximal block ascent yields the global solution\ntest_optimality(Ô_pba, S)[1]","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"1","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"For documentation of the test_optimality() function, type ?test_optimality in Julia REPL.","category":"page"},{"location":"#","page":"OTSM.jl","title":"OTSM.jl","text":"@docs\ntest_optimality","category":"page"}]
}
